"use strict";
const utils = require("@strapi/utils");
const yup = require("yup");
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const yup__namespace = /* @__PURE__ */ _interopNamespace(yup);
const RELEASE_MODEL_UID = "plugin::content-releases.release";
const RELEASE_ACTION_MODEL_UID = "plugin::content-releases.release-action";
const ACTIONS = [
  {
    section: "plugins",
    displayName: "Read",
    uid: "read",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Create",
    uid: "create",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Edit",
    uid: "update",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Delete",
    uid: "delete",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Publish",
    uid: "publish",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Remove an entry from a release",
    uid: "delete-action",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Add an entry to a release",
    uid: "create-action",
    pluginName: "content-releases"
  }
];
const { features: features$1 } = require("@strapi/strapi/dist/utils/ee");
const register = async ({ strapi: strapi2 }) => {
  if (features$1.isEnabled("cms-content-releases") && strapi2.features.future.isEnabled("contentReleases")) {
    await strapi2.admin.services.permission.actionProvider.registerMany(ACTIONS);
  }
};
const schema$1 = {
  collectionName: "strapi_releases",
  info: {
    singularName: "release",
    pluralName: "releases",
    displayName: "Release"
  },
  options: {
    draftAndPublish: false
  },
  pluginOptions: {
    "content-manager": {
      visible: false
    },
    "content-type-builder": {
      visible: false
    }
  },
  attributes: {
    name: {
      type: "string",
      required: true
    },
    releasedAt: {
      type: "datetime"
    },
    actions: {
      type: "relation",
      relation: "oneToMany",
      target: RELEASE_ACTION_MODEL_UID,
      mappedBy: "release"
    }
  }
};
const release$1 = {
  schema: schema$1
};
const schema = {
  collectionName: "strapi_release_actions",
  info: {
    singularName: "release-action",
    pluralName: "release-actions",
    displayName: "Release Action"
  },
  options: {
    draftAndPublish: false
  },
  pluginOptions: {
    "content-manager": {
      visible: false
    },
    "content-type-builder": {
      visible: false
    }
  },
  attributes: {
    type: {
      type: "enumeration",
      enum: ["publish", "unpublish"],
      required: true
    },
    entry: {
      type: "relation",
      relation: "morphToOne",
      configurable: false
    },
    contentType: {
      type: "string",
      required: true
    },
    release: {
      type: "relation",
      relation: "manyToOne",
      target: RELEASE_MODEL_UID,
      inversedBy: "actions"
    }
  }
};
const releaseAction$1 = {
  schema
};
const contentTypes = {
  release: release$1,
  "release-action": releaseAction$1
};
const getService = (name, { strapi: strapi2 } = { strapi: global.strapi }) => {
  return strapi2.plugin("content-releases").service(name);
};
const createReleaseService = ({ strapi: strapi2 }) => ({
  async create(releaseData, { user }) {
    const releaseWithCreatorFields = await utils.setCreatorFields({ user })(releaseData);
    return strapi2.entityService.create(RELEASE_MODEL_UID, {
      data: releaseWithCreatorFields
    });
  },
  async findOne(id, query = {}) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, id, {
      ...query
    });
    return release2;
  },
  findPage(query) {
    return strapi2.entityService.findPage(RELEASE_MODEL_UID, {
      ...query,
      populate: {
        actions: {
          // @ts-expect-error Ignore missing properties
          count: true
        }
      }
    });
  },
  async findManyForContentTypeEntry(contentTypeUid, entryId, {
    hasEntryAttached
  } = {
    hasEntryAttached: false
  }) {
    const whereActions = hasEntryAttached ? {
      // Find all Releases where the content type entry is present
      actions: {
        target_type: contentTypeUid,
        target_id: entryId
      }
    } : {
      // Find all Releases where the content type entry is not present
      $or: [
        {
          $not: {
            actions: {
              target_type: contentTypeUid,
              target_id: entryId
            }
          }
        },
        {
          actions: null
        }
      ]
    };
    const populateAttachedAction = hasEntryAttached ? {
      // Filter the action to get only the content type entry
      actions: {
        where: {
          target_type: contentTypeUid,
          target_id: entryId
        }
      }
    } : {};
    const releases = await strapi2.db.query(RELEASE_MODEL_UID).findMany({
      where: {
        ...whereActions,
        releasedAt: {
          $null: true
        }
      },
      populate: {
        ...populateAttachedAction
      }
    });
    return releases.map((release2) => {
      if (release2.actions?.length) {
        const [actionForEntry] = release2.actions;
        delete release2.actions;
        return {
          ...release2,
          action: actionForEntry
        };
      }
      return release2;
    });
  },
  async update(id, releaseData, { user }) {
    const updatedRelease = await utils.setCreatorFields({ user, isEdition: true })(releaseData);
    const release2 = await strapi2.entityService.update(RELEASE_MODEL_UID, id, {
      /*
       * The type returned from the entity service: Partial<Input<"plugin::content-releases.release">>
       * is not compatible with the type we are passing here: UpdateRelease.Request['body']
       */
      // @ts-expect-error see above
      data: updatedRelease
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${id}`);
    }
    return release2;
  },
  async createAction(releaseId, action) {
    const { validateEntryContentType, validateUniqueEntry } = getService("release-validation", {
      strapi: strapi2
    });
    await Promise.all([
      validateEntryContentType(action.entry.contentType),
      validateUniqueEntry(releaseId, action)
    ]);
    const { entry, type } = action;
    return strapi2.entityService.create(RELEASE_ACTION_MODEL_UID, {
      data: {
        type,
        contentType: entry.contentType,
        entry: {
          id: entry.id,
          __type: entry.contentType,
          __pivot: { field: "entry" }
        },
        release: releaseId
      },
      populate: { release: { fields: ["id"] }, entry: { fields: ["id"] } }
    });
  },
  async findActions(releaseId, query) {
    const result = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId);
    if (!result) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    return strapi2.entityService.findPage(RELEASE_ACTION_MODEL_UID, {
      ...query,
      populate: {
        entry: true
      },
      filters: {
        release: releaseId
      }
    });
  },
  async countActions(query) {
    return strapi2.entityService.count(RELEASE_ACTION_MODEL_UID, query);
  },
  async getAllContentTypeUids(releaseId) {
    const contentTypesFromReleaseActions = await strapi2.db.queryBuilder(RELEASE_ACTION_MODEL_UID).select("content_type").where({
      $and: [
        {
          release: releaseId
        }
      ]
    }).groupBy("content_type").execute();
    return contentTypesFromReleaseActions.map(({ contentType: contentTypeUid }) => contentTypeUid);
  },
  async getContentTypesDataForActions(releaseId) {
    const contentTypesUids = await this.getAllContentTypeUids(releaseId);
    const contentManagerContentTypeService = strapi2.plugin("content-manager").service("content-types");
    const contentTypesData = {};
    for (const contentTypeUid of contentTypesUids) {
      const contentTypeConfig = await contentManagerContentTypeService.findConfiguration({
        uid: contentTypeUid
      });
      contentTypesData[contentTypeUid] = {
        mainField: contentTypeConfig.settings.mainField,
        displayName: strapi2.getModel(contentTypeUid).info.displayName
      };
    }
    return contentTypesData;
  },
  async delete(releaseId) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId, {
      populate: {
        actions: {
          fields: ["id"]
        }
      }
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    if (release2.releasedAt) {
      throw new utils.errors.ValidationError("Release already published");
    }
    await strapi2.db.transaction(async () => {
      await strapi2.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
        where: {
          id: {
            $in: release2.actions.map((action) => action.id)
          }
        }
      });
      await strapi2.entityService.delete(RELEASE_MODEL_UID, releaseId);
    });
    return release2;
  },
  async publish(releaseId) {
    const releaseWithPopulatedActionEntries = await strapi2.entityService.findOne(
      RELEASE_MODEL_UID,
      releaseId,
      {
        populate: {
          actions: {
            populate: {
              entry: true
            }
          }
        }
      }
    );
    if (!releaseWithPopulatedActionEntries) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    if (releaseWithPopulatedActionEntries.releasedAt) {
      throw new utils.errors.ValidationError("Release already published");
    }
    if (releaseWithPopulatedActionEntries.actions.length === 0) {
      throw new utils.errors.ValidationError("No entries to publish");
    }
    const actions = {};
    for (const action of releaseWithPopulatedActionEntries.actions) {
      const contentTypeUid = action.contentType;
      if (!actions[contentTypeUid]) {
        actions[contentTypeUid] = {
          publish: [],
          unpublish: []
        };
      }
      if (action.type === "publish") {
        actions[contentTypeUid].publish.push(action.entry);
      } else {
        actions[contentTypeUid].unpublish.push(action.entry);
      }
    }
    const entityManagerService = strapi2.plugin("content-manager").service("entity-manager");
    await strapi2.db.transaction(async () => {
      for (const contentTypeUid of Object.keys(actions)) {
        const { publish, unpublish } = actions[contentTypeUid];
        if (publish.length > 0) {
          await entityManagerService.publishMany(publish, contentTypeUid);
        }
        if (unpublish.length > 0) {
          await entityManagerService.unpublishMany(unpublish, contentTypeUid);
        }
      }
    });
    const release2 = await strapi2.entityService.update(RELEASE_MODEL_UID, releaseId, {
      data: {
        /*
         * The type returned from the entity service: Partial<Input<"plugin::content-releases.release">> looks like it's wrong
         */
        // @ts-expect-error see above
        releasedAt: /* @__PURE__ */ new Date()
      }
    });
    return release2;
  },
  async updateAction(actionId, releaseId, update) {
    const updatedAction = await strapi2.db.query(RELEASE_ACTION_MODEL_UID).update({
      where: {
        id: actionId,
        release: releaseId
      },
      data: update
    });
    if (!updatedAction) {
      throw new utils.errors.NotFoundError(
        `Action with id ${actionId} not found in release with id ${releaseId}`
      );
    }
    return updatedAction;
  },
  async deleteAction(actionId, releaseId) {
    const deletedAction = await strapi2.db.query(RELEASE_ACTION_MODEL_UID).delete({
      where: {
        id: actionId,
        release: releaseId
      }
    });
    if (!deletedAction) {
      throw new utils.errors.NotFoundError(
        `Action with id ${actionId} not found in release with id ${releaseId}`
      );
    }
    return deletedAction;
  }
});
const createReleaseValidationService = ({ strapi: strapi2 }) => ({
  async validateUniqueEntry(releaseId, releaseActionArgs) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId, {
      populate: { actions: { populate: { entry: { fields: ["id"] } } } }
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    const isEntryInRelease = release2.actions.some(
      (action) => Number(action.entry.id) === Number(releaseActionArgs.entry.id) && action.contentType === releaseActionArgs.entry.contentType
    );
    if (isEntryInRelease) {
      throw new utils.errors.ValidationError(
        `Entry with id ${releaseActionArgs.entry.id} and contentType ${releaseActionArgs.entry.contentType} already exists in release with id ${releaseId}`
      );
    }
  },
  validateEntryContentType(contentTypeUid) {
    const contentType = strapi2.contentType(contentTypeUid);
    if (!contentType) {
      throw new utils.errors.NotFoundError(`No content type found for uid ${contentTypeUid}`);
    }
    if (!contentType.options?.draftAndPublish) {
      throw new utils.errors.ValidationError(
        `Content type with uid ${contentTypeUid} does not have draftAndPublish enabled`
      );
    }
  }
});
const services = { release: createReleaseService, "release-validation": createReleaseValidationService };
const RELEASE_SCHEMA = yup__namespace.object().shape({
  name: yup__namespace.string().trim().required()
}).required().noUnknown();
const validateRelease = utils.validateYupSchema(RELEASE_SCHEMA);
const releaseController = {
  async findMany(ctx) {
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    await permissionsManager.validateQuery(ctx.query);
    const releaseService = getService("release", { strapi });
    const isFindManyForContentTypeEntry = Boolean(ctx.query?.contentTypeUid && ctx.query?.entryId);
    if (isFindManyForContentTypeEntry) {
      const query = await permissionsManager.sanitizeQuery(ctx.query);
      const contentTypeUid = query.contentTypeUid;
      const entryId = query.entryId;
      const hasEntryAttached = typeof query.hasEntryAttached === "string" ? JSON.parse(query.hasEntryAttached) : false;
      const data = await releaseService.findManyForContentTypeEntry(contentTypeUid, entryId, {
        hasEntryAttached
      });
      ctx.body = { data };
    } else {
      const query = await permissionsManager.sanitizeQuery(ctx.query);
      const { results, pagination } = await releaseService.findPage(query);
      const data = results.map((release2) => {
        const { actions, ...releaseData } = release2;
        return {
          ...releaseData,
          actions: {
            meta: {
              count: actions.count
            }
          }
        };
      });
      ctx.body = { data, meta: { pagination } };
    }
  },
  async findOne(ctx) {
    const id = ctx.params.id;
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.findOne(id, { populate: ["createdBy"] });
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    const sanitizedRelease = await permissionsManager.sanitizeOutput(release2);
    const count = await releaseService.countActions({
      filters: {
        release: id
      }
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`Release not found for id: ${id}`);
    }
    const data = {
      ...sanitizedRelease,
      actions: {
        meta: {
          count
        }
      }
    };
    ctx.body = { data };
  },
  async create(ctx) {
    const user = ctx.state.user;
    const releaseArgs = ctx.request.body;
    await validateRelease(releaseArgs);
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.create(releaseArgs, { user });
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    ctx.body = {
      data: await permissionsManager.sanitizeOutput(release2)
    };
  },
  async update(ctx) {
    const user = ctx.state.user;
    const releaseArgs = ctx.request.body;
    const id = ctx.params.id;
    await validateRelease(releaseArgs);
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.update(id, releaseArgs, { user });
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    ctx.body = {
      data: await permissionsManager.sanitizeOutput(release2)
    };
  },
  async delete(ctx) {
    const id = ctx.params.id;
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.delete(id);
    ctx.body = {
      data: release2
    };
  },
  async publish(ctx) {
    const user = ctx.state.user;
    const id = ctx.params.id;
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.publish(id, { user });
    ctx.body = {
      data: release2
    };
  }
};
const RELEASE_ACTION_SCHEMA = utils.yup.object().shape({
  entry: utils.yup.object().shape({
    id: utils.yup.strapiID().required(),
    contentType: utils.yup.string().required()
  }).required(),
  type: utils.yup.string().oneOf(["publish", "unpublish"]).required()
});
const RELEASE_ACTION_UPDATE_SCHEMA = utils.yup.object().shape({
  type: utils.yup.string().oneOf(["publish", "unpublish"]).required()
});
const validateReleaseAction = utils.validateYupSchema(RELEASE_ACTION_SCHEMA);
const validateReleaseActionUpdateSchema = utils.validateYupSchema(RELEASE_ACTION_UPDATE_SCHEMA);
const releaseActionController = {
  async create(ctx) {
    const releaseId = ctx.params.releaseId;
    const releaseActionArgs = ctx.request.body;
    await validateReleaseAction(releaseActionArgs);
    const releaseService = getService("release", { strapi });
    const releaseAction2 = await releaseService.createAction(releaseId, releaseActionArgs);
    ctx.body = {
      data: releaseAction2
    };
  },
  async findMany(ctx) {
    const releaseId = ctx.params.releaseId;
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_ACTION_MODEL_UID
    });
    const query = await permissionsManager.sanitizeQuery(ctx.query);
    const releaseService = getService("release", { strapi });
    const { results, pagination } = await releaseService.findActions(releaseId, query);
    const allReleaseContentTypesDictionary = await releaseService.getContentTypesDataForActions(
      releaseId
    );
    const allLocales = await strapi.plugin("i18n").service("locales").find();
    const allLocalesDictionary = allLocales.reduce((acc, locale) => {
      acc[locale.code] = { name: locale.name, code: locale.code };
      return acc;
    }, {});
    const data = results.map((action) => {
      const { mainField, displayName } = allReleaseContentTypesDictionary[action.contentType];
      return {
        ...action,
        entry: {
          id: action.entry.id,
          contentType: {
            displayName,
            mainFieldValue: action.entry[mainField]
          },
          locale: allLocalesDictionary[action.entry.locale]
        }
      };
    });
    ctx.body = {
      data,
      meta: {
        pagination
      }
    };
  },
  async update(ctx) {
    const actionId = ctx.params.actionId;
    const releaseId = ctx.params.releaseId;
    const releaseActionUpdateArgs = ctx.request.body;
    await validateReleaseActionUpdateSchema(releaseActionUpdateArgs);
    const releaseService = getService("release", { strapi });
    const updatedAction = await releaseService.updateAction(
      actionId,
      releaseId,
      releaseActionUpdateArgs
    );
    ctx.body = {
      data: updatedAction
    };
  },
  async delete(ctx) {
    const actionId = ctx.params.actionId;
    const releaseId = ctx.params.releaseId;
    const deletedReleaseAction = await getService("release", { strapi }).deleteAction(
      actionId,
      releaseId
    );
    ctx.body = {
      data: deletedReleaseAction
    };
  }
};
const controllers = { release: releaseController, "release-action": releaseActionController };
const release = {
  type: "admin",
  routes: [
    {
      method: "POST",
      path: "/",
      handler: "release.create",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.create"]
            }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/",
      handler: "release.findMany",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.read"]
            }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/:id",
      handler: "release.findOne",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.read"]
            }
          }
        ]
      }
    },
    {
      method: "PUT",
      path: "/:id",
      handler: "release.update",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.update"]
            }
          }
        ]
      }
    },
    {
      method: "DELETE",
      path: "/:id",
      handler: "release.delete",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.delete"]
            }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/:id/publish",
      handler: "release.publish",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.publish"]
            }
          }
        ]
      }
    }
  ]
};
const releaseAction = {
  type: "admin",
  routes: [
    {
      method: "POST",
      path: "/:releaseId/actions",
      handler: "release-action.create",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.create-action"]
            }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/:releaseId/actions",
      handler: "release-action.findMany",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.read"]
            }
          }
        ]
      }
    },
    {
      method: "PUT",
      path: "/:releaseId/actions/:actionId",
      handler: "release-action.update",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.update"]
            }
          }
        ]
      }
    },
    {
      method: "DELETE",
      path: "/:releaseId/actions/:actionId",
      handler: "release-action.delete",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.delete-action"]
            }
          }
        ]
      }
    }
  ]
};
const routes = {
  release,
  "release-action": releaseAction
};
const { features } = require("@strapi/strapi/dist/utils/ee");
const getPlugin = () => {
  if (features.isEnabled("cms-content-releases") && strapi.features.future.isEnabled("contentReleases")) {
    return {
      register,
      contentTypes,
      services,
      controllers,
      routes
    };
  }
  return {
    contentTypes
  };
};
const index = getPlugin();
module.exports = index;
//# sourceMappingURL=index.js.map
